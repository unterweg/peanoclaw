/*
 * DefaultFluxCorrection.cpph
 *
 *  Created on: Dec 5, 2014
 *      Author: kristof
 */

template<int NumberOfUnknowns>
void peanoclaw::interSubgridCommunication::DefaultFluxCorrectionTemplate<NumberOfUnknowns>::computeFluxes(
  Patch& subgrid
) const {

  for(int dimension = 0; dimension < DIMENSIONS; dimension++) {
    double deltaTDeltaX = subgrid.getTimeIntervals().getTimestepSize() / (2 * subgrid.getSubcellSize()[dimension]);

    for(int direction = -1; direction < 2; direction += 2) {
      peanoclaw::grid::SubgridFaceIterator<NumberOfUnknowns> faceIterator
        = subgrid.getAccessor().getSubgridFaceIterator<NumberOfUnknowns>(dimension, direction);

      //TODO unterweg debug
//      std::cout << "dimension=" << dimension << " direction=" << direction << "ptr0=" << (&faceIterator) << std::endl;
      while(faceIterator.moveToNextInterfaceCell()) {
        faceIterator.moveToNextGhostCell(); //Move to first cell

        tarch::la::Vector<NumberOfUnknowns,double> outerUnknowns = faceIterator.getGhostUnknowns();
        tarch::la::Vector<NumberOfUnknowns,double> outerFluxes = outerUnknowns * outerUnknowns[1 + dimension];
        tarch::la::Vector<NumberOfUnknowns,double> innerUnknowns = faceIterator.getUnknownsUOld();
        tarch::la::Vector<NumberOfUnknowns,double> innerFluxes = innerUnknowns * innerUnknowns[1 + dimension];

        tarch::la::Vector<NumberOfUnknowns,double> fluxes = 0.5 * (outerFluxes + innerFluxes)
                + direction * deltaTDeltaX * (innerUnknowns - outerUnknowns);
        faceIterator.setFluxes(fluxes);

        //TODO unterweg debug
//        std::cout << "interfaceCell " << faceIterator.getSubcellIndex() << std::endl;
//        std::cout << "outerUnknowns=" << outerUnknowns << " outerFluxes=" << outerFluxes << std::endl
//                  << "innerUnknowns=" << innerUnknowns << " innerFluxes=" << innerFluxes << std::endl
//                  << "fluxes=" << fluxes << std::endl;

        faceIterator.skipRemainingGhostCells();
      }
    }
  }
}

template<int NumberOfUnknowns>
void peanoclaw::interSubgridCommunication::DefaultFluxCorrectionTemplate<NumberOfUnknowns>::applyCorrection(
    Patch& sourceSubgrid,
    Patch& destinationSubgrid,
    int dimension,
    int direction
) const {
  logTraceInWith4Arguments("applyCoarseGridCorrection", finePatch.toString(), coarsePatch.toString(), dimension, direction);

  double lowerTimeIntervalBound = std::max(sourceSubgrid.getTimeIntervals().getCurrentTime(), destinationSubgrid.getTimeIntervals().getCurrentTime());
  double upperTimeIntervalBound = std::min(sourceSubgrid.getTimeIntervals().getCurrentTime() + sourceSubgrid.getTimeIntervals().getTimestepSize(),
                                           destinationSubgrid.getTimeIntervals().getCurrentTime() + destinationSubgrid.getTimeIntervals().getTimestepSize());
  double timeOverlap = upperTimeIntervalBound - lowerTimeIntervalBound;
  //TODO unterweg debug
//  std::cout << "Correcting flux dimension " << dimension << " direction=" << direction << " timeOverlap=" << timeOverlap << std::endl;

  peanoclaw::geometry::HyperplaneRegion sourceRegion = peanoclaw::geometry::HyperplaneRegion::getInterfaceRegion(
    sourceSubgrid,
    destinationSubgrid
  );

  peanoclaw::grid::SubgridFaceIterator<NumberOfUnknowns> sourceIterator
    = sourceSubgrid.getAccessor().getSubgridFaceIterator<NumberOfUnknowns>(dimension, direction);
  peanoclaw::grid::SubgridFaceIterator<NumberOfUnknowns> destinationIterator
    = destinationSubgrid.getAccessor().getSubgridFaceIterator<NumberOfUnknowns>(dimension, direction);

  //TODO unterweg debug
//  std::cout << "sourceRegion=" << sourceRegion << std::endl;

  while(sourceIterator.moveToNextInterfaceCell()) {
    sourceIterator.moveToNextGhostCell();
    peanoclaw::geometry::HyperplaneRegion destinationRegion = peanoclaw::geometry::HyperplaneRegion::getInterfaceRegionForSubcell(
      destinationSubgrid,
      sourceSubgrid,
      sourceIterator.getSubcellIndex(),
      sourceRegion._dimension,
      sourceRegion._direction
    );

    tarch::la::Vector<NumberOfUnknowns, double> sourceFluxes = sourceIterator.getFluxes();

    //TODO unterweg debug
//    std::cout << "destinationRegion=" << destinationRegion << std::endl;

    destinationIterator.restart(destinationRegion);

    while(destinationIterator.moveToNextInterfaceCell()) {
      destinationIterator.moveToNextGhostCell();
      //TODO unterweg debug
//      std::cout << "sourceCell=" << sourceIterator.getSubcellIndex() << " destinationCell=" << destinationIterator.getSubcellIndex() << std::endl;

      tarch::la::Vector<NumberOfUnknowns, double> destinationFluxes = destinationIterator.getFluxes();

      //TODO unterweg debug
//      std::cout << "\ttimeOverlap=" << timeOverlap << " sourceFluxes=" << sourceFluxes << " destinationFluxes=" << destinationFluxes << " delta=" << ((sourceFluxes - destinationFluxes) * timeOverlap) << std::endl;
      destinationIterator.setUnknownsUNew(
        destinationIterator.getUnknownsUNew() + (sourceFluxes - destinationFluxes) * timeOverlap
      );
      destinationIterator.skipRemainingGhostCells();
    }
    sourceIterator.skipRemainingGhostCells();
  }

//  #ifdef Dim3
//  tarch::la::Vector<DIMENSIONS_MINUS_ONE, int> sourceSubcellIndex;
//  for(int y = 0; y < sourceRegion._size[1]; y++ ) {
//    sourceSubcellIndex[1] = y;
//  #endif
//    for(int x = 0; x < sourceRegion._size[0]; x++) {
//      sourceSubcellIndex[0] = x;
//
//      peanoclaw::geometry::HyperplaneRegion destinationRegion = peanoclaw::geometry::HyperplaneRegion::getInterfaceRegionForSubcell(
//        destinationSubgrid,
//        sourceSubgrid,
//        sourceSubcellIndex,
//        sourceRegion._dimension,
//        sourceRegion._direction
//      );
//
//    }
//  #ifdef Dim3
//  }
//  #endif

//  if(tarch::la::smaller(destinationSubgrid.getTimeIntervals().getCurrentTime(), sourceSubgrid.getTimeIntervals().getCurrentTime())) {
//    peanoclaw::grid::SubgridAccessor sourceAccessor = sourceSubgrid.getAccessor();
//    peanoclaw::grid::SubgridAccessor destinationAccessor = destinationSubgrid.getAccessor();
//
//    //Create description of the fine patch's face to be traversed
//    tarch::la::Vector<DIMENSIONS, int> face = sourceSubgrid.getSubdivisionFactor();
//    face(dimension) = 1;
//    tarch::la::Vector<DIMENSIONS, int> offset(0);
//    if(direction == 1) {
//      offset(dimension) = sourceSubgrid.getSubdivisionFactor()(dimension) - 1;
//    }
//
//    //Create search region that needs to be considered around the neighboring cell in the coarse patch
//    tarch::la::Vector<DIMENSIONS, int> searchRegion = tarch::la::Vector<DIMENSIONS, int>(2);
//    searchRegion(dimension) = 1;
//
//    logDebug("applyFluxCorrection", "face=" << face << ", offset=" << offset << ", searchRegion=" << searchRegion);
//
//    tarch::la::Vector<DIMENSIONS, double> sourceSubcellSize = sourceSubgrid.getSubcellSize();
//    tarch::la::Vector<DIMENSIONS, double> destinationSubcellSize = destinationSubgrid.getSubcellSize();
//
//    const peanoclaw::grid::TimeIntervals& sourceTimeIntervals = sourceSubgrid.getTimeIntervals();
//    const peanoclaw::grid::TimeIntervals& destinationTimeIntervals = destinationSubgrid.getTimeIntervals();
//    double timestepOverlap
//      = std::max(0.0,   std::min(sourceTimeIntervals.getCurrentTime() + sourceTimeIntervals.getTimestepSize(), destinationTimeIntervals.getCurrentTime() + destinationTimeIntervals.getTimestepSize())
//                    - std::max(sourceTimeIntervals.getCurrentTime(), destinationTimeIntervals.getCurrentTime()));
//
//    if(tarch::la::equals(timestepOverlap, 0.0)) {
//      return;
//    }
//
//    double sourceSubcellVolume = tarch::la::volume(sourceSubcellSize);
//    double destinationSubcellVolume = tarch::la::volume(destinationSubcellSize);
//
//    dfor(subcellIndexInFace, face) {
//      tarch::la::Vector<DIMENSIONS, int> subcellIndexInSourcePatch = subcellIndexInFace + offset;
//      tarch::la::Vector<DIMENSIONS, int> ghostlayerSubcellIndexInSourcePatch = subcellIndexInSourcePatch;
//      ghostlayerSubcellIndexInSourcePatch(dimension) += direction;
//
//      tarch::la::Vector<DIMENSIONS, double> subcellPositionInSourcePatch = sourceSubgrid.getSubcellPosition(subcellIndexInSourcePatch);
//      tarch::la::Vector<DIMENSIONS, double> neighboringSubcellCenterInDestinationPatch = subcellPositionInSourcePatch;
//      neighboringSubcellCenterInDestinationPatch(dimension) += destinationSubcellSize(dimension) * direction * 0.5;
//
//      tarch::la::Vector<DIMENSIONS, int> neighboringSubcellIndexInDestinationPatch =
//          (tarch::la::multiplyComponents(
//               neighboringSubcellCenterInDestinationPatch - destinationSubgrid.getPosition(),
//               tarch::la::invertEntries(destinationSubcellSize)
//          )).convertScalar<int>();
//      tarch::la::Vector<DIMENSIONS, int> ghostlayerSubcellIndexInDestinationPatch = neighboringSubcellIndexInDestinationPatch;
//      ghostlayerSubcellIndexInDestinationPatch(dimension) -= direction;
//
//      logDebug("applyFluxCorrection", "Correcting from cell " << subcellIndexInSourcePatch);
//
//      dfor(neighborOffset, searchRegion) {
//        tarch::la::Vector<DIMENSIONS, int> adjacentSubcellIndexInDestinationPatch = neighboringSubcellIndexInDestinationPatch + neighborOffset;
//
//        correctFluxBetweenCells(
//          dimension,
//          direction,
//          timestepOverlap,
//          sourceSubgrid,
//          destinationSubgrid,
//          sourceAccessor,
//          destinationAccessor,
//          sourceTimeIntervals,
//          destinationTimeIntervals,
//          destinationSubcellVolume,
//          sourceSubcellSize,
//          destinationSubcellSize,
//          subcellIndexInSourcePatch,
//          ghostlayerSubcellIndexInSourcePatch,
//          adjacentSubcellIndexInDestinationPatch,
//          ghostlayerSubcellIndexInDestinationPatch
//        );
//      }
//    }
//  }
  logTraceOut("applyCoarseGridCorrection");
}
